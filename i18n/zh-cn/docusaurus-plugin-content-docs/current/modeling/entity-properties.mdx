---
sidebar_position: 3030
title: 实体属性
description: 如何使用 Linq Entity Framework 配置和映射实体属性
author: roji
ms.date: 10/12/2021
uid: core/modeling/entity-properties
---

import DataAnnotationsIgnoreProperty from '!!raw-loader!../../../../../static/samples/Modeling/EntityProperties/DataAnnotations/IgnoreProperty.cs';
import FluentAPIIgnoreProperty from '!!raw-loader!../../../../../static/samples/Modeling/EntityProperties/FluentAPI/IgnoreProperty.cs';

import DataAnnotationsColumnName from '!!raw-loader!../../../../../static/samples/Modeling/EntityProperties/DataAnnotations/ColumnName.cs';
import FluentAPIColumnName from '!!raw-loader!../../../../../static/samples/Modeling/EntityProperties/FluentAPI/ColumnName.cs';

import DataAnnotationsColumnDataType from '!!raw-loader!../../../../../static/samples/Modeling/EntityProperties/DataAnnotations/ColumnDataType.cs';
import FluentAPIColumnDataType from '!!raw-loader!../../../../../static/samples/Modeling/EntityProperties/FluentAPI/ColumnDataType.cs';

import DataAnnotationsMaxLength from '!!raw-loader!../../../../../static/samples/Modeling/EntityProperties/DataAnnotations/MaxLength.cs';
import FluentAPIMaxLength from '!!raw-loader!../../../../../static/samples/Modeling/EntityProperties/FluentAPI/MaxLength.cs';

import DataAnnotationsPrecisionAndScale from '!!raw-loader!../../../../../static/samples/Modeling/EntityProperties/DataAnnotations/PrecisionAndScale.cs';
import FluentAPIPrecisionAndScale from '!!raw-loader!../../../../../static/samples/Modeling/EntityProperties/FluentAPI/PrecisionAndScale.cs';

import DataAnnotationsUnicode from '!!raw-loader!../../../../../static/samples/Modeling/EntityProperties/DataAnnotations/Unicode.cs';
import FluentAPIUnicode from '!!raw-loader!../../../../../static/samples/Modeling/EntityProperties/FluentAPI/Unicode.cs';

import NullableReferenceTypesCustomerWithoutNullableReferenceTypes from '!!raw-loader!../../../../../static/samples/Miscellaneous/NullableReferenceTypes/CustomerWithoutNullableReferenceTypes.cs';
import NullableReferenceTypesCustomer from '!!raw-loader!../../../../../static/samples/Miscellaneous/NullableReferenceTypes/Customer.cs';

import DataAnnotationsRequired from '!!raw-loader!../../../../../static/samples/Modeling/EntityProperties/DataAnnotations/Required.cs';
import FluentAPIRequired from '!!raw-loader!../../../../../static/samples/Modeling/EntityProperties/FluentAPI/Required.cs';

import CollationsProgram from '!!raw-loader!../../../../../static/samples/Miscellaneous/Collations/Program.cs';

import DataAnnotationsColumnComment from '!!raw-loader!../../../../../static/samples/Modeling/EntityProperties/DataAnnotations/ColumnComment.cs';
import FluentAPIColumnComment from '!!raw-loader!../../../../../static/samples/Modeling/EntityProperties/FluentAPI/ColumnComment.cs';

import DataAnnotationsColumnOrder from '!!raw-loader!../../../../../static/samples/Modeling/EntityProperties/DataAnnotations/ColumnOrder.cs';
import FluentAPIColumnOrder from '!!raw-loader!../../../../../static/samples/Modeling/EntityProperties/FluentAPI/ColumnOrder.cs';


# 实体属性

模型中的每个实体类型都有一组属性，EF Core 将从数据库中读取和写入这些属性。 如果使用的是关系数据库，实体属性将映射到表列。

## 已包含和已排除的属性

按照约定，所有具有 Getter 和 Setter 的公共属性都将包含在模型中。

可以按如下所示排除特定属性：

<Tabs groupId="operating-code">
  <TabItem value="Annotations" label="数据注解">
    <CodeSnippets title="C#" language="csharp" fragment="IgnoreProperty" metastring='{6}' showLineNumbers>{DataAnnotationsIgnoreProperty}</CodeSnippets>
  </TabItem>
  <TabItem
    value="Fluent"
    label="Fluent API"
  >
    <CodeSnippets title="C#" language="csharp" fragment="IgnoreProperty" metastring='{3,4}' showLineNumbers>{FluentAPIIgnoreProperty}</CodeSnippets>
  </TabItem>
</Tabs>

***

## 列名

按照约定，使用关系数据库时，实体属性将映射到与属性同名的表列。

如果希望配置具有不同名称的列，可以按以下代码片段进行操作：

<Tabs groupId="operating-code">
  <TabItem value="Annotations" label="数据注解">
    <CodeSnippets title="C#" language="csharp" fragment="ColumnName" metastring='{3}' showLineNumbers>{DataAnnotationsColumnName}</CodeSnippets>
  </TabItem>
  <TabItem
    value="Fluent"
    label="Fluent API"
  >
    <CodeSnippets title="C#" language="csharp" fragment="ColumnName" metastring='{3-5}' showLineNumbers>{FluentAPIColumnName}</CodeSnippets>
  </TabItem>
</Tabs>

***

## 列数据类型

使用关系数据库时，数据库提供程序会根据属性的 .NET 类型选择数据类型。 它还会考虑其他元数据，例如配置的[最大长度](#maximum-length)、属性是否是主键的一部分等等。

例如，SQL Server 将 DateTime 属性映射到 datetime2(7) 列，将 string 属性映射到 nvarchar(max) 列（或对于用作键的属性，映射到 nvarchar(450)）。

还可以配置列以指定列的确切数据类型。 例如，以下代码将 Url 配置为非 unicode 字符串，其最大长度为 200，并将 Rating 配置为十进制，其精度为 5，小数位数为 2：

<Tabs groupId="operating-code">
  <TabItem value="Annotations" label="数据注解">
    <CodeSnippets title="C#" language="csharp" fragment="ColumnDataType" metastring='{5,8}' showLineNumbers>{DataAnnotationsColumnDataType}</CodeSnippets>
  </TabItem>
  <TabItem
    value="Fluent"
    label="Fluent API"
  >
    <CodeSnippets title="C#" language="csharp" fragment="ColumnDataType" metastring='{6-7}' showLineNumbers>{FluentAPIColumnDataType}</CodeSnippets>
  </TabItem>
</Tabs>

***

### 最大长度

配置最大长度可向数据库提供程序提供有关为给定属性选择适当列数据类型的提示。 最大长度仅适用于数组数据类型，如 string 和 byte[]。

> [!NOTE]
在向提供程序传递数据之前，实体框架不会执行任何最大长度的验证。 而是由提供程序或数据存储根据情况进行验证。 例如，当面向 SQL Server 时，超过最大长度将导致异常，因为基础列的数据类型不允许存储多余的数据。
> 
在下面的示例中，将最大长度配置为 500 将导致在 SQL Server 上创建 nvarchar(500) 类型的列：

<Tabs groupId="operating-code">
  <TabItem value="Annotations" label="数据注解">
    <CodeSnippets title="C#" language="csharp" fragment="MaxLength" metastring='{5}' showLineNumbers>{DataAnnotationsMaxLength}</CodeSnippets>
  </TabItem>
  <TabItem
    value="Fluent"
    label="Fluent API"
  >
    <CodeSnippets title="C#" language="csharp" fragment="MaxLength" metastring='{3-5}' showLineNumbers>{FluentAPIMaxLength}</CodeSnippets>
  </TabItem>
</Tabs>

***

### 精度和小数位数

某些关系数据类型支持精度和小数位数 Facet，它们用于控制可以存储哪些值，以及列需要多少存储。 哪些数据类型支持精度和小数位数取决于数据库，但在大多数数据库中，decimal 和 DateTime 类型支持这些 Facet。 对于 decimal 属性，精度用于定义表示列将包含的任何值所需的最大位数，小数位数用于定义所需的最大小数位数。 对于 DateTime 属性，精度用于定义表示秒的小数部分所需的最大位数，不使用小数位数。

> [!NOTE]
在向提供程序传递数据之前，实体框架不会执行任何精度或小数位数的验证。 而是由提供程序或数据存储根据情况进行验证。 例如，当面向 SQL Server 时，数据类型为 datetime 的列不允许设置精度，而 datetime2 的精度可以介于 0 和 7 之间（含这两个值）。
> 

在以下示例中，将 Score 属性配置为精度为 14 和小数位数为 2 将导致在 SQL Server 上创建 decimal(14,2) 类型的列，将 LastUpdated 属性配置为精度为 3 将导致创建 datetime2(3) 类型的列：

<Tabs groupId="operating-code">
  <TabItem value="Annotations" label="数据注解">
    <CodeSnippets title="C#" language="csharp" fragment="PrecisionAndScale" metastring='{4,6}' showLineNumbers>{DataAnnotationsPrecisionAndScale}</CodeSnippets>

    如果不先定义精度，则永远不会定义小数位数，因此用于定义小数位数的数据注释为 [Precision(precision, scale)]。
  </TabItem>
  <TabItem
    value="Fluent"
    label="Fluent API"
  >
    <CodeSnippets title="C#" language="csharp" fragment="PrecisionAndScale" metastring='{5,9}' showLineNumbers>{FluentAPIPrecisionAndScale}</CodeSnippets>
    
    如果不先定义精度，则永远不会定义小数位数，因此用于定义小数位数的 Fluent API 为 HasPrecision(precision, scale)。
  </TabItem>
</Tabs>

***

### Unicode

在某些关系数据库中，存在不同的类型来表示 Unicode 和非 Unicode 文本数据。 例如，在 SQL Server 中，nvarchar(x)用于表示 UTF-16 中的 Unicode 数据，而varchar(x)用于表示非 Unicode 数据 (，但请参阅[SQL Server UTF-8 支持](xref:core/providers/sql-server/columns#unicode-and-utf-8)). 对于不支持此概念的数据库，配置此概念将不起作用。

默认情况下，文本属性配置为 Unicode。 可以将列配置为非 Unicode，如下所示：

<Tabs groupId="operating-code">
  <TabItem value="Annotations" label="数据注解">
    <CodeSnippets title="C#" language="csharp" fragment="Unicode" metastring='{4,6}' showLineNumbers>{DataAnnotationsUnicode}</CodeSnippets>
  </TabItem>
  <TabItem
    value="Fluent"
    label="Fluent API"
  >
    <CodeSnippets title="C#" language="csharp" fragment="Unicode" metastring='{5,9}' showLineNumbers>{FluentAPIUnicode}</CodeSnippets>
  </TabItem>
</Tabs>

***

## 必需和可选属性

如果属性包含 null 是有效的，则该属性被视为可选属性。 如果 null 不是要分配给属性的有效值，则它被视为必需属性。 映射到关系数据库架构时，必需属性创建为不可为 null 的列，可选属性创建为可为 null 的列。

### 约定

按照约定，其 .NET 类型可包含 null 的属性将配置为可选属性，而 .NET 类型不能包含 null 的属性将配置为必需属性。 例如，所有具有 .NET 值类型 (intdecimal、bool等) 的属性都配置为必需，并且具有可为 null 的 .NET 值类型的所有属性 (int?decimal?、bool?等) 配置为可选。

C# 8 引入了一项名为 [可为 null 引用类型 (NRT)](https://learn.microsoft.com/zh-cn/dotnet/csharp/tutorials/nullable-reference-types) 的新功能，该功能允许对引用类型进行批注，指示引用类型能否包含 null。 默认情况下，此功能在新项目模板中处于启用状态，但在现有项目中保持禁用状态，除非显式选择启用此功能。 可为 Null 的引用类型通过以下方式影响 EF Core 的行为：

* 如果禁用可为 null 的引用类型，则使用 .NET 引用类型的所有属性都按约定 (（例如 string) ）配置为可选。
* 如果启用了可为 null 的引用类型，则基于属性的 .NET 类型的 C# 为 Null 性来配置属性：string? 将配置为可选属性，但 string 将配置为必需属性。

以下示例显示了具有必需属性和可选属性的实体类型，禁用并启用可为 null 的引用功能：

<Tabs groupId="operating-NRT">
  <TabItem value="Without NRT" label="无 NRT (默认)">
    <CodeSnippets title="C#" language="csharp" fragment="Customer" metastring='{5,8}' showLineNumbers>{NullableReferenceTypesCustomerWithoutNullableReferenceTypes}</CodeSnippets>
  </TabItem>
  <TabItem
    value="With NRT"
    label="有 NRT"
  >
    <CodeSnippets title="C#" language="csharp" fragment="Customer" metastring='{4-6}' showLineNumbers>{NullableReferenceTypesCustomer}</CodeSnippets>
  </TabItem>
</Tabs>

***

建议使用可为 null 的引用类型，因为它将 C# 代码中表示的为 Null 性传递到 EF Core 的模型和数据库，并且可避免使用 Fluent API 或数据注释来表示同一概念两次。

> [!NOTE]
建议使用可为 null 的引用类型，因为它将 C# 代码中表示的为 Null 性传递到 EF Core 的模型和数据库，并且可避免使用 Fluent API 或数据注释来表示同一概念两次。
> 

若要详细了解可为 null 的引用类型以及如何将其与 EF Core 配合使用， [请参阅此功能的专用文档页](https://learn.microsoft.com/zh-cn/ef/core/miscellaneous/nullable-reference-types).

### 显式配置

按约定为可选属性的属性可以配置为必需属性，如下所示：

<Tabs groupId="operating-code">
  <TabItem value="Annotations" label="数据注解">
    <CodeSnippets title="C#" language="csharp" fragment="Required" metastring='{5}' showLineNumbers>{DataAnnotationsRequired}</CodeSnippets>
  </TabItem>
  <TabItem
    value="Fluent"
    label="Fluent API"
  >
    <CodeSnippets title="C#" language="csharp" fragment="Required" metastring='{3-5}' showLineNumbers>{FluentAPIRequired}</CodeSnippets>
  </TabItem>
</Tabs>

***

## 列排序规则

可以定义文本列的排序规则，以确定如何比较和排序。 例如，以下代码片段将 SQL Server 列配置为不区分大小写：

<CodeSnippets title="C#" language="csharp" fragment="ColumnCollation" metastring='{4,6}' showLineNumbers>{CollationsProgram}</CodeSnippets>

如果数据库中的所有列都需要使用特定的排序规则，请改为在数据库级别定义排序规则。

有关 EF Core 对排序规则的支持的常规信息，请参阅 [排序规则文档页](https://learn.microsoft.com/zh-cn/ef/core/miscellaneous/collations-and-case-sensitivity).

## 列注释

可以对数据库列设置任意文本注释，从而在数据库中记录架构：

<Tabs groupId="operating-code">
  <TabItem value="Annotations" label="数据注解">
    <CodeSnippets title="C#" language="csharp" fragment="ColumnComment" metastring='{5}' showLineNumbers>{DataAnnotationsColumnComment}</CodeSnippets>
  </TabItem>
  <TabItem
    value="Fluent"
    label="Fluent API"
  >
    <CodeSnippets title="C#" language="csharp" fragment="ColumnComment" metastring='{5}' showLineNumbers>{FluentAPIColumnComment}</CodeSnippets>
  </TabItem>
</Tabs>

***

## 列顺序

默认情况下，在使用 [迁移](https://learn.microsoft.com/zh-cn/ef/core/managing-schemas/migrations/), 创建表时，EF Core 首先为主键列排序，然后为实体类型和从属类型的属性排序，最后为基类型中的属性排序。 但是，你可以指定不同的列顺序：

<Tabs groupId="operating-code">
  <TabItem value="Annotations" label="数据注解">
    <CodeSnippets title="C#" language="csharp" fragment="snippet_ColumnAttribute"  showLineNumbers>{DataAnnotationsColumnOrder}</CodeSnippets>
  </TabItem>
  <TabItem
    value="Fluent"
    label="Fluent API"
  >
    <CodeSnippets title="C#" language="csharp" fragment="snippet_HasColumnOrder" showLineNumbers>{FluentAPIColumnOrder}</CodeSnippets>
  </TabItem>
</Tabs>

***

请注意，在一般情况下，大多数数据库仅支持在创建表时对列进行排序。 这意味着不能使用列顺序特性对现有表中的列进行重新排序。