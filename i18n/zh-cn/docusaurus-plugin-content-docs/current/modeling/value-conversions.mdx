---
sidebar_position: 3080
title: å€¼è½¬æ¢
description: Configuring value converters in an Linq Entity Framework model
author: ajcvickers
ms.date: 01/16/2021
uid: core/modeling/value-conversions
---

import EnumToStringConversions from '!!raw-loader!../../../../../static/samples/Modeling/ValueConversions/EnumToStringConversions.cs';

import BulkConfigurationCurrencyConverter from '!!raw-loader!../../../../../static/samples/Modeling/BulkConfiguration/CurrencyConverter.cs';

import BulkConfigurationCurrencyContext from '!!raw-loader!../../../../../static/samples/Modeling/BulkConfiguration/CurrencyContext.cs';

import SimpleValueObject from '!!raw-loader!../../../../../static/samples/Modeling/ValueConversions/SimpleValueObject.cs';

import CompositeValueObject from '!!raw-loader!../../../../../static/samples/Modeling/ValueConversions/CompositeValueObject.cs';

import PrimitiveCollection from '!!raw-loader!../../../../../static/samples/Modeling/ValueConversions/PrimitiveCollection.cs';

import EncryptPropertyValues from '!!raw-loader!../../../../../static/samples/Modeling/ValueConversions/EncryptPropertyValues.cs';






# å€¼è½¬æ¢

å€¼è½¬æ¢å™¨å¯åœ¨ä»æ•°æ®åº“è¯»å–æˆ–å‘å…¶ä¸­å†™å…¥å±æ€§å€¼æ—¶è½¬æ¢å±æ€§å€¼ã€‚ æ­¤è½¬æ¢å¯ä»¥æ˜¯ä»åŒä¸€ç±»å‹çš„ä¸€ä¸ªå€¼è½¬æ¢ä¸ºå¦ä¸€ä¸ªå€¼ï¼ˆä¾‹å¦‚åŠ å¯†å­—ç¬¦ä¸²ï¼‰ï¼Œä¹Ÿå¯ä»¥æ˜¯ä»ä¸€ç§ç±»å‹çš„å€¼è½¬æ¢ä¸ºå¦ä¸€ç§ç±»å‹çš„å€¼ï¼ˆä¾‹å¦‚æ•°æ®åº“ä¸­æšä¸¾å€¼å’Œå­—ç¬¦ä¸²çš„ç›¸äº’è½¬æ¢ï¼‰ã€‚

> [!TIP]
é€šè¿‡ [ä» GitHub ä¸‹è½½ç¤ºä¾‹ä»£ç ](https://github.com/dotnet/EntityFramework.Docs/tree/main/samples/core/Modeling/ValueConversions/)ï¼Œä½ å¯è¿è¡Œå¹¶è°ƒè¯•åˆ°æœ¬æ–‡æ¡£ä¸­çš„æ‰€æœ‰ä»£ç ã€‚
> 
## æ¦‚è¿°

å€¼è½¬æ¢å™¨çš„æŒ‡å®šæ¶‰åŠ ModelClrType å’Œ ProviderClrTypeã€‚ æ¨¡å‹ç±»å‹æ˜¯å®ä½“ç±»å‹ä¸­çš„å±æ€§çš„ .NET ç±»å‹ã€‚ æä¾›ç¨‹åºç±»å‹æ˜¯æ•°æ®åº“æä¾›ç¨‹åºç†è§£çš„ .NET ç±»å‹ã€‚ ä¾‹å¦‚ï¼Œè‹¥è¦åœ¨æ•°æ®åº“ä¸­å°†æšä¸¾ä¿å­˜ä¸ºå­—ç¬¦ä¸²ï¼Œæ¨¡å‹ç±»å‹æ˜¯æšä¸¾çš„ç±»å‹ï¼Œè€Œæä¾›ç¨‹åºç±»å‹æ˜¯ Stringã€‚ è¿™ä¸¤ç§ç±»å‹å¯ä»¥ç›¸åŒã€‚

> [!NOTE]
å·²ä¸ºå€¼è½¬æ¢é…ç½®çš„å±æ€§å¯èƒ½éœ€è¦æŒ‡å®šä¸€ä¸ª  [`ValueComparer<T>`](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.entityframeworkcore.changetracking.valuecomparer-1)ã€‚ æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…ä»¥ä¸‹ç¤ºä¾‹å’Œ [å€¼æ¯”è¾ƒå™¨](zh-cn/docs/modeling/value-comparers)æ–‡æ¡£.
> 
## é…ç½®å€¼è½¬æ¢å™¨

å€¼è½¬æ¢æ˜¯åœ¨ [DbContext.OnModelCreating](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.entityframeworkcore.dbcontext.onmodelcreating) ä¸­é…ç½®çš„ã€‚ ä¾‹å¦‚ï¼Œå‡è®¾å°†ä¸€ä¸ªæšä¸¾å’Œå®ä½“ç±»å‹å®šä¹‰ä¸ºï¼š

<!--
        public class Rider
        {
            public int Id { get; set; }
            public EquineBeast Mount { get; set; }
        }

        public enum EquineBeast
        {
            Donkey,
            Mule,
            Horse,
            Unicorn
        }
-->

<CodeSnippets title="C#" language="csharp" fragment="BeastAndRider" showLineNumbers>{EnumToStringConversions}</CodeSnippets>


å¯ä»¥å°†è½¬æ¢é…ç½®ä¸º [OnModelCreating](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.entityframeworkcore.dbcontext.onmodelcreating) å°†æšä¸¾å€¼ï¼ˆå¦‚â€œDonkeyâ€ã€â€œMuleâ€ç­‰å­—ç¬¦ä¸²ï¼‰å­˜å‚¨åœ¨æ•°æ®åº“ä¸­;åªéœ€æä¾›ä¸€ä¸ªä» `ModelClrType` è½¬æ¢åˆ° `ProviderClrType` çš„å‡½æ•°ï¼Œå¦ä¸€ä¸ªå‡½æ•°ç”¨äºç›¸åçš„è½¬æ¢ï¼š
<!--
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                modelBuilder
                    .Entity<Rider>()
                    .Property(e => e.Mount)
                    .HasConversion(
                        v => v.ToString(),
                        v => (EquineBeast)Enum.Parse(typeof(EquineBeast), v));
            }
-->

<CodeSnippets title="C#" language="csharp" fragment="ExplicitConversion" showLineNumbers>{EnumToStringConversions}</CodeSnippets>

> [!NOTE]
ç»ä¸ä¼šå‘å€¼è½¬æ¢å™¨ä¼ é€’ null å€¼ã€‚ æ•°æ®åº“åˆ—ä¸­çš„ null åœ¨å®ä½“å®ä¾‹ä¸­å§‹ç»ˆä¸º nullï¼Œåä¹‹äº¦ç„¶ã€‚ è¿™ä½¿å®ç°è½¬æ¢æ›´å®¹æ˜“ï¼Œå¹¶å…è®¸åœ¨å¯ä¸º null å’Œä¸å¯ä¸º null çš„å±æ€§ä¹‹é—´å…±äº«è½¬æ¢ã€‚
> 
### æ‰¹é‡é…ç½®å€¼è½¬æ¢å™¨

ä¸ºä½¿ç”¨ç›¸å…³ CLR ç±»å‹çš„æ¯ä¸ªå±æ€§é…ç½®ç›¸åŒçš„å€¼è½¬æ¢å™¨å¾ˆå¸¸è§ã€‚ å¯ä»¥é’ˆå¯¹æ•´ä¸ª [æ¨¡å‹ä½¿ç”¨é¢„çº¦å®šæ¨¡å‹é…ç½®](https://learn.microsoft.com/zh-cn/ef/core/modeling/bulk-configuration#pre-convention-configuration) ä¸€æ¬¡ï¼Œè€Œä¸æ˜¯ä¸ºæ¯ä¸ªå±æ€§æ‰‹åŠ¨æ‰§è¡Œæ­¤æ“ä½œã€‚ ä¸ºæ­¤ï¼Œè¯·å°†å€¼è½¬æ¢å™¨å®šä¹‰ä¸ºç±»ï¼š

<CodeSnippets title="C#" language="csharp" fragment="CurrencyConverter" showLineNumbers>{BulkConfigurationCurrencyConverter}</CodeSnippets>

ç„¶åï¼Œåœ¨ä¸Šä¸‹æ–‡ç±»å‹ä¸­é‡å†™ [ConfigureConventions](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.entityframeworkcore.dbcontext.configureconventions) å¹¶é…ç½®è½¬æ¢å™¨ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

<CodeSnippets title="C#" language="csharp" fragment="ConfigureConventions" showLineNumbers>{BulkConfigurationCurrencyContext}</CodeSnippets>

## é¢„å®šä¹‰çš„è½¬æ¢

EF Core å«æœ‰è®¸å¤šé¢„å®šä¹‰è½¬æ¢ï¼Œä¸éœ€è¦æ‰‹åŠ¨ç¼–å†™è½¬æ¢å‡½æ•°ã€‚ è€Œæ˜¯æ ¹æ®æ¨¡å‹ä¸­çš„å±æ€§ç±»å‹å’Œè¯·æ±‚çš„æ•°æ®åº“æä¾›ç¨‹åºç±»å‹é€‰å–è¦ä½¿ç”¨çš„è½¬æ¢ã€‚

ä¾‹å¦‚ï¼Œæšä¸¾åˆ°å­—ç¬¦ä¸²è½¬æ¢ç”¨ä½œä¸Šé¢çš„ç¤ºä¾‹ï¼Œä½†åœ¨æä¾›ç¨‹åºç±»å‹é…ç½®ä¸º `string` ä½¿ç”¨æ³›å‹ç±»å‹ [`HasConversion`](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.entityframeworkcore.metadata.builders.propertybuilder.hasconversion)æ—¶ï¼ŒEF Core å®é™…ä¸Šä¼šè‡ªåŠ¨æ‰§è¡Œæ­¤æ“ä½œï¼š

<!--
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                modelBuilder
                    .Entity<Rider>()
                    .Property(e => e.Mount)
                    .HasConversion<string>();
            }
-->

<CodeSnippets title="C#" language="csharp" fragment="ConversionByClrType" showLineNumbers>{EnumToStringConversions}</CodeSnippets>

å¯é€šè¿‡æ˜¾å¼åœ°æŒ‡å®šæ•°æ®åº“åˆ—ç±»å‹å®ç°ç›¸åŒçš„æ“ä½œã€‚ ä¾‹å¦‚ï¼Œå¦‚æœå®ä½“ç±»å‹çš„å®šä¹‰å¦‚ä¸‹ï¼š

<Tabs groupId="operating-code">
  <TabItem value="Annotations" label="æ•°æ®æ³¨è§£">
    <CodeSnippets title="C#" language="csharp" fragment="ConversionByDatabaseType" showLineNumbers>{EnumToStringConversions}</CodeSnippets>
  </TabItem>
  <TabItem
    value="Fluent"
    label="Fluent API"
  >
    <CodeSnippets title="C#" language="csharp" fragment="ConversionByDatabaseTypeFluent" showLineNumbers>{EnumToStringConversions}</CodeSnippets>
  </TabItem>
</Tabs>

***

ç„¶åï¼Œæšä¸¾å€¼å°†ä¿å­˜ä¸ºæ•°æ®åº“ä¸­çš„å­—ç¬¦ä¸²ï¼Œè€Œæ— éœ€è¿› [OnModelCreating](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.entityframeworkcore.dbcontext.onmodelcreating) ä¸€æ­¥é…ç½®ã€‚

## ValueConverter ç±»

å¦‚ä¸Šæ‰€ç¤ºè°ƒç”¨ [`HasConversion`](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.entityframeworkcore.metadata.builders.propertybuilder.hasconversion) å°†åˆ›å»ºä¸€ä¸ª [`ValueConverter<TModel,TProvider>`](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.entityframeworkcore.storage.valueconversion.valueconverter-2) å®ä¾‹ï¼Œå¹¶åœ¨å±æ€§ä¸Šè®¾ç½®å®ƒã€‚ å¯æ”¹ä¸ºæ˜¾å¼åœ°åˆ›å»º ValueConverterã€‚ ä¾‹å¦‚ï¼š

<!--
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                var converter = new ValueConverter<EquineBeast, string>(
                    v => v.ToString(),
                    v => (EquineBeast)Enum.Parse(typeof(EquineBeast), v));

                modelBuilder
                    .Entity<Rider>()
                    .Property(e => e.Mount)
                    .HasConversion(converter);
            }
-->

<CodeSnippets title="C#" language="csharp" fragment="ConversionByConverterInstance" showLineNumbers>{EnumToStringConversions}</CodeSnippets>

å¤šä¸ªå±æ€§ä½¿ç”¨åŒä¸€ä¸ªè½¬æ¢æ—¶ï¼Œè¿™éå¸¸æœ‰ç”¨ã€‚

## å†…ç½®è½¬æ¢å™¨

å¦‚ä¸Šæ‰€è¿°ï¼ŒLEF Core é™„å¸¦äº†ä¸€ç»„é¢„å®šä¹‰ [`ValueConverter<TModel,TProvider>`](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.entityframeworkcore.storage.valueconversion.valueconverter-2) ç±»ï¼Œè¿™äº› [Microsoft.EntityFrameworkCore.Storage.ValueConversion](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.entityframeworkcore.storage.valueconversion) ç±»ä½äºå‘½åç©ºé—´ä¸­ã€‚ åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼ŒEF å°†æ ¹æ®æ¨¡å‹ä¸­å±æ€§çš„ç±»å‹å’Œåœ¨æ•°æ®åº“ä¸­è¯·æ±‚çš„ç±»å‹ï¼Œé€‰æ‹©é€‚å½“çš„å†…ç½®è½¬æ¢å™¨ï¼Œæ­£å¦‚ä¸Šé¢çš„æšä¸¾è½¬æ¢ç¤ºä¾‹æ‰€ç¤ºã€‚ ä¾‹å¦‚ï¼Œå¯¹ `bool` å±æ€§ä½¿ç”¨ `.HasConversion<int>()` ä¼šä½¿ EF Core å°†å¸ƒå°”å€¼è½¬æ¢ä¸ºæ•°å€¼é›¶å’Œä¸€ï¼š
<!--
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                modelBuilder
                    .Entity<User>()
                    .Property(e => e.IsActive)
                    .HasConversion<int>();
            }
-->

<CodeSnippets title="C#" language="csharp" fragment="ConversionByBuiltInBoolToInt" showLineNumbers>{EnumToStringConversions}</CodeSnippets>

è¿™ä¸åˆ›å»ºå†…ç½® [`BoolToZeroOneConverter<TProvider>`](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.entityframeworkcore.storage.valueconversion.booltozerooneconverter-1) å®ä¾‹çš„åŠŸèƒ½ç›¸åŒï¼Œå¹¶æ˜¾å¼è®¾ç½®å®ƒï¼š


<!--
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                var converter = new BoolToZeroOneConverter<int>();

                modelBuilder
                    .Entity<User>()
                    .Property(e => e.IsActive)
                    .HasConversion(converter);
            }
-->

<CodeSnippets title="C#" language="csharp" fragment="ConversionByBuiltInBoolToIntExplicit" showLineNumbers>{EnumToStringConversions}</CodeSnippets>


ä¸‹è¡¨æ±‡æ€»äº†ä»æ¨¡å‹/å±æ€§ç±»å‹åˆ°æ•°æ®åº“æä¾›ç¨‹åºç±»å‹çš„å¸¸ç”¨é¢„å®šä¹‰è½¬æ¢ã€‚ è¡¨ä¸­çš„ `any_numeric_type` è¡¨ç¤º `int`, `short`, `long`, `byte`, `uint`, `ushort`, `ulong`, `sbyte`, `char`, `decimal`, `float`, æˆ– `double`.


| æ¨¡å‹/å±æ€§ç±»å‹	       | æä¾›ç¨‹åº/æ•°æ®åº“ç±»å‹      | è½¬æ¢                                                      | ä½¿ç”¨æƒ…å†µ
|:--------------------|------------------------|-----------------------------------------------------------|------
| bool                | any_numeric_type       | False/true to 0/1                                         | `.HasConversion<any_numeric_type>()`
|                     | any_numeric_type       | False/true to any two numbers                             | ä½¿ç”¨ [`BoolToTwoValuesConverter<TProvider>`](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.entityframeworkcore.storage.valueconversion.booltotwovaluesconverter-1)
|                     | string                 | False/true to "N"/"Y"                                     | `.HasConversion<string>()`
|                     | string                 | False/true to any two strings                             | ä½¿ç”¨ [`BoolToStringConverter`](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.entityframeworkcore.storage.valueconversion.booltostringconverter)
| any_numeric_type    | bool                   | 0/1 to false/true                                         | `.HasConversion<bool>()`
|                     | any_numeric_type       | Simple cast                                               | `.HasConversion<any_numeric_type>()`
|                     | string                 | The number as a string                                    | `.HasConversion<string>()`
| Enum                | any_numeric_type       | The numeric value of the enum                             | `.HasConversion<any_numeric_type>()`
|                     | string                 | The string representation of the enum value               | `.HasConversion<string>()`
| string              | bool                   | Parses the string as a bool                               | `.HasConversion<bool>()`
|                     | any_numeric_type       | Parses the string as the given numeric type               | `.HasConversion<any_numeric_type>()`
|                     | char                   | The first character of the string                         | `.HasConversion<char>()`
|                     | DateTime               | Parses the string as a DateTime                           | `.HasConversion<DateTime>()`
|                     | DateTimeOffset         | Parses the string as a DateTimeOffset                     | `.HasConversion<DateTimeOffset>()`
|                     | TimeSpan               | Parses the string as a TimeSpan                           | `.HasConversion<TimeSpan>()`
|                     | Guid                   | Parses the string as a Guid                               | `.HasConversion<Guid>()`
|                     | byte[]                 | The string as UTF8 bytes                                  | `.HasConversion<byte[]>()`
| char                | string                 | A single character string                                 | `.HasConversion<string>()`
| DateTime            | long                   | Encoded date/time preserving DateTime.Kind                | `.HasConversion<long>()`
|                     | long                   | Ticks                                                     | ä½¿ç”¨ [`DateTimeToTicksConverter`](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.entityframeworkcore.storage.valueconversion.datetimetoticksconverter)
|                     | string                 | Invariant culture date/time string                        | `.HasConversion<string>()`
| DateTimeOffset      | long                   | Encoded date/time with offset                             | `.HasConversion<long>()`
|                     | string                 | Invariant culture date/time string with offset            | `.HasConversion<string>()`
| TimeSpan            | long                   | Ticks                                                     | `.HasConversion<long>()`
|                     | string                 | Invariant culture time span string                        | `.HasConversion<string>()`
| Uri                 | string                 | The URI as a string                                       | `.HasConversion<string>()`
| PhysicalAddress     | string                 | The address as a string                                   | `.HasConversion<string>()`
|                     | byte[]                 | Bytes in big-endian network order                         | `.HasConversion<byte[]>()`
| IPAddress           | string                 | The address as a string                                   | `.HasConversion<string>()`
|                     | byte[]                 | Bytes in big-endian network order                         | `.HasConversion<byte[]>()`
| Guid                | string                 | The GUID in 'dddddddd-dddd-dddd-dddd-dddddddddddd' format | `.HasConversion<string>()`
|                     | byte[]                 | Bytes in .NET binary serialization order                  | `.HasConversion<byte[]>()`

è¯·æ³¨æ„ï¼Œè¿™äº›è½¬æ¢å‡å®šå€¼çš„æ ¼å¼é€‚ç”¨äºè½¬æ¢ã€‚ ä¾‹å¦‚ï¼Œå¦‚æœå­—ç¬¦ä¸²å€¼æ— æ³•åˆ†æä¸ºæ•°å­—ï¼Œä»å­—ç¬¦ä¸²åˆ°æ•°å­—çš„è½¬æ¢å°†å¤±è´¥ã€‚

å†…ç½®è½¬æ¢å™¨çš„å®Œæ•´åˆ—è¡¨å¦‚ä¸‹ï¼š

* Converting bool properties:
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.BoolToStringConverter> - Bool to strings such as "N" and "Y"
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.BoolToTwoValuesConverter%601> - Bool to any two values
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.BoolToZeroOneConverter%601> - Bool to zero and one
* Converting byte array properties:
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.BytesToStringConverter> - Byte array to Base64-encoded string
* Any conversion that requires only a type-cast
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.CastingConverter%602> - Conversions that require only a type cast
* Converting char properties:
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.CharToStringConverter> - Char to single character string
* Converting <xref:System.DateTimeOffset> properties:
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.DateTimeOffsetToBinaryConverter> - <xref:System.DateTimeOffset> to binary-encoded 64-bit value
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.DateTimeOffsetToBytesConverter> - <xref:System.DateTimeOffset> to byte array
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.DateTimeOffsetToStringConverter> - <xref:System.DateTimeOffset> to string
* Converting <xref:System.DateTime> properties:
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.DateTimeToBinaryConverter> - <xref:System.DateTime> to 64-bit value including DateTimeKind
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.DateTimeToStringConverter> - <xref:System.DateTime> to string
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.DateTimeToTicksConverter> - <xref:System.DateTime> to ticks
* Converting enum properties:
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.EnumToNumberConverter%602> - Enum to underlying number
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.EnumToStringConverter%601> - Enum to string
* Converting <xref:System.Guid> properties:
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.GuidToBytesConverter> - <xref:System.Guid> to byte array
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.GuidToStringConverter> - <xref:System.Guid> to string
* Converting <xref:System.Net.IPAddress> properties:
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.IPAddressToBytesConverter> - <xref:System.Net.IPAddress> to byte array
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.IPAddressToStringConverter> - <xref:System.Net.IPAddress> to string
* Converting numeric (int, double, decimal, etc.) properties:
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.NumberToBytesConverter%601> - Any numerical value to byte array
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.NumberToStringConverter%601> - Any numerical value to string
* Converting <xref:System.Net.NetworkInformation.PhysicalAddress> properties:
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.PhysicalAddressToBytesConverter> - <xref:System.Net.NetworkInformation.PhysicalAddress> to byte array
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.PhysicalAddressToStringConverter> - <xref:System.Net.NetworkInformation.PhysicalAddress> to string
* Converting string properties:
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.StringToBoolConverter> - Strings such as "N" and "Y" to bool
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.StringToBytesConverter> - String to UTF8 bytes
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.StringToCharConverter> - String to character
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.StringToDateTimeConverter> - String to <xref:System.DateTime>
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.StringToDateTimeOffsetConverter> - String to <xref:System.DateTimeOffset>
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.StringToEnumConverter%601> - String to enum
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.StringToGuidConverter> - String to <xref:System.Guid>
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.StringToNumberConverter%601> - String to numeric type
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.StringToTimeSpanConverter> - String to <xref:System.TimeSpan>
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.StringToUriConverter> - String to <xref:System.Uri>
* Converting <xref:System.TimeSpan> properties:
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.TimeSpanToStringConverter> - <xref:System.TimeSpan> to string
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.TimeSpanToTicksConverter> - <xref:System.TimeSpan> to ticks
* Converting <xref:System.Uri> properties:
  * <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.UriToStringConverter> - <xref:System.Uri> to string

Note that all the built-in converters are stateless and so a single instance can be safely shared by multiple properties.

## Column facets and mapping hints

Some database types have facets that modify how the data is stored. These include:

* Precision and scale for decimals and date/time columns
* Size/length for binary and string columns
* Unicode for string columns

These facets can be configured in the normal way for a property that uses a value converter, and will apply to the converted database type. For example, when converting from an enum to strings, we can specify that the database column should be non-Unicode and store up to 20 characters:

<!--
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                modelBuilder
                    .Entity<Rider>()
                    .Property(e => e.Mount)
                    .HasConversion<string>()
                    .HasMaxLength(20)
                    .IsUnicode(false);
            }
-->
[!code-csharp[ConversionByClrTypeWithFacets](../../../samples/core/Modeling/ValueConversions/EnumToStringConversions.cs?name=ConversionByClrTypeWithFacets)]

Or, when creating the converter explicitly:

<!--
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                var converter = new ValueConverter<EquineBeast, string>(
                    v => v.ToString(),
                    v => (EquineBeast)Enum.Parse(typeof(EquineBeast), v));

                modelBuilder
                    .Entity<Rider>()
                    .Property(e => e.Mount)
                    .HasConversion(converter)
                    .HasMaxLength(20)
                    .IsUnicode(false);
            }
-->
[!code-csharp[ConversionByConverterInstanceWithFacets](../../../samples/core/Modeling/ValueConversions/EnumToStringConversions.cs?name=ConversionByConverterInstanceWithFacets)]

This results in a `varchar(20)` column when using EF Core migrations against SQL Server:

```sql
CREATE TABLE [Rider] (
    [Id] int NOT NULL IDENTITY,
    [Mount] varchar(20) NOT NULL,
    CONSTRAINT [PK_Rider] PRIMARY KEY ([Id]));
```

However, if by default all `EquineBeast` columns should be `varchar(20)`, then this information can be given to the value converter as a <xref:Microsoft.EntityFrameworkCore.Storage.ValueConversion.ConverterMappingHints>. For example:

<!--
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                var converter = new ValueConverter<EquineBeast, string>(
                    v => v.ToString(),
                    v => (EquineBeast)Enum.Parse(typeof(EquineBeast), v),
                    new ConverterMappingHints(size: 20, unicode: false));

                modelBuilder
                    .Entity<Rider>()
                    .Property(e => e.Mount)
                    .HasConversion(converter);
            }
-->
[!code-csharp[ConversionByConverterInstanceWithMappingHints](../../../samples/core/Modeling/ValueConversions/EnumToStringConversions.cs?name=ConversionByConverterInstanceWithMappingHints)]

Now any time this converter is used, the database column will be non-unicode with a max length of 20. However, these are only hints since they are overridden by any facets explicitly set on the mapped property.

## ç¤ºä¾‹

### ç®€å•å€¼å¯¹è±¡

æ­¤ç¤ºä¾‹ä½¿ç”¨ç®€å•ç±»å‹æ¥åŒ…è£…åŸºå…ƒç±»å‹ã€‚ å¸Œæœ›æ¨¡å‹ä¸­çš„ç±»å‹æ¯”åŸºå…ƒç±»å‹æ›´å…·ä½“ï¼ˆå› è€Œæ›´å…·ç±»å‹å®‰å…¨æ€§ï¼‰æ—¶ï¼Œè¿™å¾ˆæœ‰ç”¨ã€‚ åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œè¯¥ç±»å‹ä¸º `Dollars`ï¼Œå®ƒåŒ…è£…å°æ•°åŸºå…ƒï¼š

<!--
        public readonly struct Dollars
        {
            public Dollars(decimal amount) 
                => Amount = amount;
            
            public decimal Amount { get; }

            public override string ToString() 
                => $"${Amount}";
        }
-->

<CodeSnippets title="C#" language="csharp" fragment="SimpleValueObject" showLineNumbers>{SimpleValueObject}</CodeSnippets>

è¿™å¯ç”¨äºå®ä½“ç±»å‹ä¸­ï¼š

<!--
        public class Order
        {
            public int Id { get; set; }

            public Dollars Price { get; set; }
        }
-->

<CodeSnippets title="C#" language="csharp" fragment="SimpleValueObjectModel" showLineNumbers>{SimpleValueObject}</CodeSnippets>

è¿˜å¯åœ¨å­˜å‚¨åˆ°æ•°æ®åº“ä¸­æ—¶è¢«è½¬æ¢ä¸ºåŸºæœ¬ `decimal`ï¼š

<!--
                modelBuilder.Entity<Order>()
                    .Property(e => e.Price)
                    .HasConversion(
                        v => v.Amount,
                        v => new Dollars(v));
-->

<CodeSnippets title="C#" language="csharp" fragment="ConfigureImmutableStructProperty" showLineNumbers>{SimpleValueObject}</CodeSnippets>

> [!NOTE]
 This value object is implemented as a [readonly struct](/dotnet/csharp/language-reference/builtin-types/struct). This means that EF Core can snapshot and compare values without issue. See [Value Comparers](xref:core/modeling/value-comparers) for more information.
> 

### å¤åˆå€¼å¯¹è±¡

åœ¨ä¸Šä¸€ä¸ªç¤ºä¾‹ä¸­ï¼Œå€¼å¯¹è±¡ç±»å‹ä»…åŒ…å«ä¸€ä¸ªå±æ€§ã€‚ æ›´å¸¸è§çš„æ˜¯ï¼šå€¼å¯¹è±¡ç±»å‹ç»„æˆå…±åŒæ„æˆä¸€ä¸ªåŸŸæ¦‚å¿µçš„å¤šä¸ªå±æ€§ã€‚ ä¾‹å¦‚ï¼Œä¸€ä¸ªé€šç”¨çš„ `Money` ç±»å‹åŒ…å«é‡‘é¢å’Œè´§å¸ï¼š

<!--
        public readonly struct Money
        {
            [JsonConstructor]
            public Money(decimal amount, Currency currency)
            {
                Amount = amount;
                Currency = currency;
            }

            public override string ToString()
                => (Currency == Currency.UsDollars ? "$" : "Â£") + Amount;

            public decimal Amount { get; }
            public Currency Currency { get; }
        }

        public enum Currency
        {
            UsDollars,
            PoundsStirling
        }
-->

<CodeSnippets title="C#" language="csharp" fragment="CompositeValueObject" showLineNumbers>{CompositeValueObject}</CodeSnippets>


å¯ä»¥åƒä»¥å‰ä¸€æ ·åœ¨å®ä½“ç±»å‹ä¸­ä½¿ç”¨æ­¤å€¼å¯¹è±¡ï¼š

<!--
        public class Order
        {
            public int Id { get; set; }

            public Money Price { get; set; }
        }
-->

<CodeSnippets title="C#" language="csharp" fragment="CompositeValueObjectModel" showLineNumbers>{CompositeValueObject}</CodeSnippets>

å€¼è½¬æ¢å™¨ç›®å‰åªèƒ½æ‰§è¡Œå€¼ä¸ä¸€ä¸ªæ•°æ®åº“åˆ—ä¹‹é—´çš„è½¬æ¢ã€‚ æ­¤é™åˆ¶æ„å‘³ç€å¯¹è±¡çš„æ‰€æœ‰å±æ€§å€¼éƒ½å¿…é¡»è¢«ç¼–ç ä¸ºä¸€ä¸ªåˆ—å€¼ã€‚ è¿™é€šå¸¸é€šè¿‡åºåˆ—åŒ–å¯¹è±¡è¿›å…¥æ•°æ®åº“æ—¶è¿›è¡Œå¤„ç†ï¼Œç„¶ååœ¨å‡ºè·¯æ—¶å†æ¬¡ååºåˆ—åŒ–å®ƒã€‚ä¾‹å¦‚ï¼Œä½¿ç”¨ [`System.Text.Json`](https://learn.microsoft.com/zh-cn/dotnet/api/system.text.json)ï¼š
<!--
                modelBuilder.Entity<Order>()
                    .Property(e => e.Price)
                    .HasConversion(
                        v => JsonSerializer.Serialize(v, null),
                        v => JsonSerializer.Deserialize<Money>(v, null));
-->

<CodeSnippets title="C#" language="csharp" fragment="ConfigureCompositeValueObject" showLineNumbers>{CompositeValueObject}</CodeSnippets>

> [!NOTE]
åœ¨ EF Core 6.0 ä¸­ï¼Œæˆ‘ä»¬è®¡åˆ’å…è®¸å°†ä¸€ä¸ªå¯¹è±¡æ˜ å°„åˆ°å¤šä¸ªåˆ—ï¼Œä»è€Œä¸å¿…ä½¿ç”¨åºåˆ—åŒ–ã€‚ [GitHub é—®é¢˜ #13947](https://github.com/dotnet/efcore/issues/13947) å¯¹æ­¤è¿›è¡Œè·Ÿè¸ªã€‚
> 

> [!NOTE]
As with the previous example, this value object is implemented as a [readonly struct](/dotnet/csharp/language-reference/builtin-types/struct). This means that EF Core can snapshot and compare values without issue. See [Value Comparers](xref:core/modeling/value-comparers) for more information.
> 

### åŸºå…ƒçš„é›†åˆ

åºåˆ—åŒ–è¿˜å¯ç”¨äºå­˜å‚¨åŸºå…ƒå€¼çš„é›†åˆã€‚ ä¾‹å¦‚ï¼š

<!--
        public class Post
        {
            public int Id { get; set; }
            public string Title { get; set; }
            public string Contents { get; set; }

            public ICollection<string> Tags { get; set; }
        }
-->

<CodeSnippets title="C#" language="csharp" fragment="PrimitiveCollectionModel" showLineNumbers>{PrimitiveCollection}</CodeSnippets>

å†æ¬¡ä½¿ç”¨ [`System.Text.Json`](https://learn.microsoft.com/zh-cn/dotnet/api/system.text.json) ï¼š


<!--
                modelBuilder.Entity<Post>()
                    .Property(e => e.Tags)
                    .HasConversion(
                        v => JsonSerializer.Serialize(v, null),
                        v => JsonSerializer.Deserialize<List<string>>(v, null),
                        new ValueComparer<ICollection<string>>(
                            (c1, c2) => c1.SequenceEqual(c2),
                            c => c.Aggregate(0, (a, v) => HashCode.Combine(a, v.GetHashCode())),
                            c => (ICollection<string>)c.ToList()));
-->

<CodeSnippets title="C#" language="csharp" fragment="ConfigurePrimitiveCollection" showLineNumbers>{PrimitiveCollection}</CodeSnippets>


`ICollection<string>` è¡¨ç¤ºå¯å˜å¼•ç”¨ç±»å‹ã€‚ è¿™æ„å‘³ç€éœ€è¦ä¸€ä¸ªï¼Œ [`ValueComparer<T>`](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.entityframeworkcore.changetracking.valuecomparer-1) ä»¥ä¾¿ EF Core å¯ä»¥æ­£ç¡®è·Ÿè¸ªå’Œæ£€æµ‹æ›´æ”¹ã€‚ æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…[`å€¼æ¯”è¾ƒå™¨`](https://learn.microsoft.com/zh-cn/ef/core/modeling/value-comparers)ã€‚

### Collections of value objects

Combining the previous two examples together we can create a collection of value objects. For example, consider an `AnnualFinance` type that models blog finances for a single year:

<!--
        public readonly struct AnnualFinance
        {
            [JsonConstructor]
            public AnnualFinance(int year, Money income, Money expenses)
            {
                Year = year;
                Income = income;
                Expenses = expenses;
            }

            public int Year { get; }
            public Money Income { get; }
            public Money Expenses { get; }
            public Money Revenue => new Money(Income.Amount - Expenses.Amount, Income.Currency);
        }
-->
[!code-csharp[ValueObjectCollection](../../../samples/core/Modeling/ValueConversions/ValueObjectCollection.cs?name=ValueObjectCollection)]

This type composes several of the `Money` types we created previously:

<!--
        public readonly struct Money
        {
            [JsonConstructor]
            public Money(decimal amount, Currency currency)
            {
                Amount = amount;
                Currency = currency;
            }

            public override string ToString()
                => (Currency == Currency.UsDollars ? "$" : "Â£") + Amount;

            public decimal Amount { get; }
            public Currency Currency { get; }
        }

        public enum Currency
        {
            UsDollars,
            PoundsStirling
        }
-->
[!code-csharp[ValueObjectCollectionMoney](../../../samples/core/Modeling/ValueConversions/ValueObjectCollection.cs?name=ValueObjectCollectionMoney)]

We can then add a collection of `AnnualFinance` to our entity type:

<!--
        public class Blog
        {
            public int Id { get; set; }
            public string Name { get; set; }
            
            public IList<AnnualFinance> Finances { get; set; }
        }
-->
[!code-csharp[ValueObjectCollectionModel](../../../samples/core/Modeling/ValueConversions/ValueObjectCollection.cs?name=ValueObjectCollectionModel)]

And again use serialization to store this:

<!--
                modelBuilder.Entity<Blog>()
                    .Property(e => e.Finances)
                    .HasConversion(
                        v => JsonSerializer.Serialize(v, null),
                        v => JsonSerializer.Deserialize<List<AnnualFinance>>(v, null),
                        new ValueComparer<IList<AnnualFinance>>(
                            (c1, c2) => c1.SequenceEqual(c2),
                            c => c.Aggregate(0, (a, v) => HashCode.Combine(a, v.GetHashCode())),
                            c => (IList<AnnualFinance>)c.ToList()));
-->
[!code-csharp[ConfigureValueObjectCollection](../../../samples/core/Modeling/ValueConversions/ValueObjectCollection.cs?name=ConfigureValueObjectCollection)]

> [!NOTE]
> As before, this conversion requires a <xref:Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer%601>. See [Value Comparers](xref:core/modeling/value-comparers) for more information.

### Value objects as keys

Sometimes primitive key properties may be wrapped in value objects to add an additional level of type-safety in assigning values. For example, we could implement a key type for blogs, and a key type for posts:

<!--
        public readonly struct BlogKey
        {
            public BlogKey(int id) => Id = id;
            public int Id { get; }
        }

        public readonly struct PostKey
        {
            public PostKey(int id) => Id = id;
            public int Id { get; }
        }
-->
[!code-csharp[KeyValueObjects](../../../samples/core/Modeling/ValueConversions/KeyValueObjects.cs?name=KeyValueObjects)]

These can then be used in the domain model:

<!--
        public class Blog
        {
            public BlogKey Id { get; set; }
            public string Name { get; set; }

            public ICollection<Post> Posts { get; set; }
        }

        public class Post
        {
            public PostKey Id { get; set; }

            public string Title { get; set; }
            public string Content { get; set; }

            public BlogKey? BlogId { get; set; }
            public Blog Blog { get; set; }
        }
-->
[!code-csharp[KeyValueObjectsModel](../../../samples/core/Modeling/ValueConversions/KeyValueObjects.cs?name=KeyValueObjectsModel)]

Notice that `Blog.Id` cannot accidentally be assigned a `PostKey`, and `Post.Id` cannot accidentally be assigned a `BlogKey`. Similarly, the `Post.BlogId` foreign key property must be assigned a `BlogKey`.

> [!NOTE]
> Showing this pattern does not mean we recommend it. Carefully consider whether this level of abstraction is helping or hampering your development experience. Also, consider using navigations and generated keys instead of dealing with key values directly.

These key properties can then be mapped using value converters:

<!--
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                var blogKeyConverter = new ValueConverter<BlogKey, int>(
                    v => v.Id,
                    v => new BlogKey(v));

                modelBuilder.Entity<Blog>().Property(e => e.Id).HasConversion(blogKeyConverter);

                modelBuilder.Entity<Post>(
                    b =>
                        {
                            b.Property(e => e.Id).HasConversion(v => v.Id, v => new PostKey(v));
                            b.Property(e => e.BlogId).HasConversion(blogKeyConverter);
                        });
            }
-->
[!code-csharp[ConfigureKeyValueObjects](../../../samples/core/Modeling/ValueConversions/KeyValueObjects.cs?name=ConfigureKeyValueObjects)]

> [!NOTE]
> Currently key properties with conversions cannot use generated key values. Vote for [GitHub issue #11597](https://github.com/dotnet/efcore/issues/11597) to have this limitation removed.

### Use ulong for timestamp/rowversion

SQL Server supports automatic [optimistic concurrency](xref:core/saving/concurrency) using [8-byte binary `rowversion`/`timestamp` columns](/sql/t-sql/data-types/rowversion-transact-sql). These are always read from and written to the database using an 8-byte array. However, byte arrays are a mutable reference type, which makes them somewhat painful to deal with. Value converters allow the `rowversion` to instead be mapped to a `ulong` property, which is much more appropriate and easy to use than the byte array. For example, consider a `Blog` entity with a ulong concurrency token:

<!--
        public class Blog
        {
            public int Id { get; set; }
            public string Name { get; set; }
            public ulong Version { get; set; }
        }
-->
[!code-csharp[ULongConcurrencyModel](../../../samples/core/Modeling/ValueConversions/ULongConcurrency.cs?name=ULongConcurrencyModel)]

This can be mapped to a SQL server `rowversion` column using a value converter:

<!--
                modelBuilder.Entity<Blog>()
                    .Property(e => e.Version)
                    .IsRowVersion()
                    .HasConversion<byte[]>();
-->
[!code-csharp[ConfigureULongConcurrency](../../../samples/core/Modeling/ValueConversions/ULongConcurrency.cs?name=ConfigureULongConcurrency)]

### Specify the DateTime.Kind when reading dates

SQL Server discards the <xref:System.DateTime.Kind%2A?displayProperty=nameWithType> flag when storing a <xref:System.DateTime> as a [`datetime`](/sql/t-sql/data-types/datetime-transact-sql) or [`datetime2`](/sql/t-sql/data-types/datetime2-transact-sql). This means that DateTime values coming back from the database always have a <xref:System.DateTimeKind> of `Unspecified`.

Value converters can be used in two ways to deal with this. First, EF Core has a value converter that creates an 8-byte opaque value which preserves the `Kind` flag. For example:

<!--
                modelBuilder.Entity<Post>()
                    .Property(e => e.PostedOn)
                    .HasConversion<long>();
-->
[!code-csharp[ConfigurePreserveDateTimeKind1](../../../samples/core/Modeling/ValueConversions/PreserveDateTimeKind.cs?name=ConfigurePreserveDateTimeKind1)]

This allows DateTime values with different `Kind` flags to be mixed in the database.

The problem with this approach is that the database no longer has recognizable `datetime` or `datetime2` columns. So instead it is common to always store UTC time (or, less commonly, always local time) and then either ignore the `Kind` flag or set it to the appropriate value using a value converter. For example, the converter below ensures that the `DateTime` value read from the database will have the <xref:System.DateTimeKind> `UTC`:

<!--
                modelBuilder.Entity<Post>()
                    .Property(e => e.LastUpdated)
                    .HasConversion(
                        v => v,
                        v => new DateTime(v.Ticks, DateTimeKind.Utc));
-->
[!code-csharp[ConfigurePreserveDateTimeKind2](../../../samples/core/Modeling/ValueConversions/PreserveDateTimeKind.cs?name=ConfigurePreserveDateTimeKind2)]

If a mix of local and UTC values are being set in entity instances, then the converter can be used to convert appropriately before inserting. For example:

<!--
                modelBuilder.Entity<Post>()
                    .Property(e => e.LastUpdated)
                    .HasConversion(
                        v => v.ToUniversalTime(),
                        v => new DateTime(v.Ticks, DateTimeKind.Utc));
-->
[!code-csharp[ConfigurePreserveDateTimeKind3](../../../samples/core/Modeling/ValueConversions/PreserveDateTimeKind.cs?name=ConfigurePreserveDateTimeKind3)]

> [!NOTE]
> Carefully consider unifying all database access code to use UTC time all the time, only dealing with local time when presenting data to users.

### Use case-insensitive string keys

Some databases, including SQL Server, perform case-insensitive string comparisons by default. .NET, on the other hand, performs case-sensitive string comparisons by default. This means that a foreign key value like "DotNet" will match the primary key value "dotnet" on SQL Server, but will not match it in EF Core. A value comparer for keys can be used to force EF Core into case-insensitive string comparisons like in the database. For example, consider a blog/posts model with string keys:

<!--
        public class Blog
        {
            public string Id { get; set; }
            public string Name { get; set; }

            public ICollection<Post> Posts { get; set; }
        }

        public class Post
        {
            public string Id { get; set; }
            public string Title { get; set; }
            public string Content { get; set; }

            public string BlogId { get; set; }
            public Blog Blog { get; set; }
        }
-->
[!code-csharp[CaseInsensitiveStringsModel](../../../samples/core/Modeling/ValueConversions/CaseInsensitiveStrings.cs?name=CaseInsensitiveStringsModel)]

This will not work as expected if some of the `Post.BlogId` values have different casing. The errors caused by this will depend on what the application is doing, but typically involve graphs of objects that are not [fixed-up](xref:core/change-tracking/relationship-changes) correctly, and/or updates that fail because the FK value is wrong. A value comparer can be used to correct this:

<!--
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                var comparer = new ValueComparer<string>(
                    (l, r) => string.Equals(l, r, StringComparison.OrdinalIgnoreCase),
                    v => v.ToUpper().GetHashCode(),
                    v => v);

                modelBuilder.Entity<Blog>()
                    .Property(e => e.Id)
                    .Metadata.SetValueComparer(comparer);

                modelBuilder.Entity<Post>(
                    b =>
                        {
                            b.Property(e => e.Id).Metadata.SetValueComparer(comparer);
                            b.Property(e => e.BlogId).Metadata.SetValueComparer(comparer);
                        });
            }
-->
[!code-csharp[ConfigureCaseInsensitiveStrings](../../../samples/core/Modeling/ValueConversions/CaseInsensitiveStrings.cs?name=ConfigureCaseInsensitiveStrings)]

> [!NOTE]
> .NET string comparisons and database string comparisons can differ in more than just case sensitivity. This pattern works for simple ASCII keys, but may fail for keys with any kind of culture-specific characters. See [Collations and Case Sensitivity](xref:core/miscellaneous/collations-and-case-sensitivity) for more information.

### Handle fixed-length database strings

The previous example did not need a value converter. However, a converter can be useful for fixed-length database string types like `char(20)` or `nchar(20)`. Fixed-length strings are padded to their full length whenever a value is inserted into the database. This means that a key value of "`dotnet`" will be read back from the database as "`dotnet..............`", where `.` represents a space character. This will then not compare correctly with key values that are not padded.

A value converter can be used to trim the padding when reading key values. This can be combined with the value comparer in the previous example to compare fixed length case-insensitive ASCII keys correctly. For example:

<!--
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                var converter = new ValueConverter<string, string>(
                    v => v,
                    v => v.Trim());
                
                var comparer = new ValueComparer<string>(
                    (l, r) => string.Equals(l, r, StringComparison.OrdinalIgnoreCase),
                    v => v.ToUpper().GetHashCode(),
                    v => v);

                modelBuilder.Entity<Blog>()
                    .Property(e => e.Id)
                    .HasColumnType("char(20)")
                    .HasConversion(converter, comparer);

                modelBuilder.Entity<Post>(
                    b =>
                        {
                            b.Property(e => e.Id).HasColumnType("char(20)").HasConversion(converter, comparer);
                            b.Property(e => e.BlogId).HasColumnType("char(20)").HasConversion(converter, comparer);
                        });
            }
-->
[!code-csharp[ConfigureFixedLengthStrings](../../../samples/core/Modeling/ValueConversions/FixedLengthStrings.cs?name=ConfigureFixedLengthStrings)]

### åŠ å¯†å±æ€§å€¼

å€¼è½¬æ¢å™¨å¯ç”¨äºåœ¨å°†å±æ€§å€¼å‘é€åˆ°æ•°æ®åº“ä¹‹å‰å¯¹å…¶åŠ å¯†ï¼Œå†åœ¨å‘é€å›æ¥æ—¶è§£å¯†ã€‚ä¾‹å¦‚ï¼Œä½¿ç”¨å­—ç¬¦ä¸²åè½¬æ›¿ä»£å®é™…åŠ å¯†ç®—æ³•ï¼š

<!--
                modelBuilder.Entity<User>().Property(e => e.Password).HasConversion(
                    v => new string(v.Reverse().ToArray()),
                    v => new string(v.Reverse().ToArray()));
-->

<CodeSnippets title="C#" language="csharp" fragment="ConfigureEncryptPropertyValues" showLineNumbers>{EncryptPropertyValues}</CodeSnippets>

> [!NOTE]
ç›®å‰æ²¡æœ‰ä»»ä½•æ–¹æ³•å¯ä»¥ä»å€¼è½¬æ¢å™¨å†…è·å–å¯¹å½“å‰ DbContext æˆ–å…¶ä»–ä¼šè¯çŠ¶æ€çš„å¼•ç”¨ã€‚ è¿™é™åˆ¶äº†å¯ä»¥ä½¿ç”¨çš„åŠ å¯†ç±»å‹ã€‚ æŠ•ç¥¨èµæˆ [`GitHub é—®é¢˜ #11597`](https://github.com/dotnet/efcore/issues/12205)ï¼Œä»¥æ¶ˆé™¤æ­¤é™åˆ¶ã€‚
> 
> [!WARNING]
//TODO:åˆ†æè¿™ç§æƒ…å†µå¯èƒ½æ€§
å¦‚æœé€šè¿‡è‡ªè¡ŒåŠ å¯†ä¿æŠ¤æ¥æ•æ„Ÿæ•°æ®ï¼Œç¡®ä¿äº†è§£æ‰€æœ‰å¯èƒ½çš„å½±å“ã€‚ è¯·è€ƒè™‘æ”¹ä¸ºä½¿ç”¨é¢„å…ˆç”Ÿæˆçš„åŠ å¯†æœºåˆ¶ï¼Œä¾‹å¦‚ SQL Server ä¸Šçš„ [Always Encrypted](https://learn.microsoft.com/zh-cn/sql/relational-databases/security/encryption/always-encrypted-database-engine)ã€‚
> 

## Limitations

There are a few known current limitations of the value conversion system:

* As noted above, `null` cannot be converted. Please vote (ğŸ‘) for [GitHub issue #13850](https://github.com/dotnet/efcore/issues/13850) if this is something you need.
* There is currently no way to spread a conversion of one property to multiple columns or vice-versa. Please vote (ğŸ‘) for [GitHub issue #13947](https://github.com/dotnet/efcore/issues/13947) if this is something you need.
* Value generation is not supported for most keys mapped through value converters. Please vote (ğŸ‘) for [GitHub issue #11597](https://github.com/dotnet/efcore/issues/11597) if this is something you need.
* Value conversions cannot reference the current DbContext instance. Please vote (ğŸ‘) for [GitHub issue #12205](https://github.com/dotnet/efcore/issues/12205) if this is something you need.
* Parameters using value-converted types cannot currently be used in raw SQL APIs. Please vote (ğŸ‘) for [GitHub issue #27534](https://github.com/dotnet/efcore/issues/27354) if this is something you need.

Removal of these limitations is being considered for future releases.
