---
sidebar_position: 3020
title: 实体类型
description: 如何使用 Linq Entity Framework 配置和映射实体类型
author: AndriySvyryd
ms.date: 10/25/2021
uid: core/modeling/entity-types
---


import EntityTypes from '!!raw-loader!../../../../../static/samples/Modeling/EntityTypes/EntityTypes.cs';

import DataAnnotationsTableName from '!!raw-loader!../../../../../static/samples/Modeling/EntityTypes/DataAnnotations/TableName.cs';
import FluentAPITableName from '!!raw-loader!../../../../../static/samples/Modeling/EntityTypes/FluentAPI/TableName.cs';

import DataAnnotationsTableNameAndSchema from '!!raw-loader!../../../../../static/samples/Modeling/EntityTypes/DataAnnotations/TableNameAndSchema.cs';
import FluentAPITableNameAndSchema from '!!raw-loader!../../../../../static/samples/Modeling/EntityTypes/FluentAPI/TableNameAndSchema.cs';

import DataAnnotationsDefaultSchema from '!!raw-loader!../../../../../static/samples/Modeling/EntityTypes/DataAnnotations/DefaultSchema.cs';
import FluentAPIDefaultSchema from '!!raw-loader!../../../../../static/samples/Modeling/EntityTypes/FluentAPI/DefaultSchema.cs';


import EntityTypesProgram from '!!raw-loader!../../../../../static/samples/Modeling/EntityTypes/Program.cs';

import DataAnnotationsTableComment from '!!raw-loader!../../../../../static/samples/Modeling/EntityTypes/DataAnnotations/TableComment.cs';
import FluentAPITableComment from '!!raw-loader!../../../../../static/samples/Modeling/EntityTypes/FluentAPI/TableComment.cs';


import DataAnnotationsViewNameAndSchema from '!!raw-loader!../../../../../static/samples/Modeling/EntityTypes/DataAnnotations/ViewNameAndSchema.cs';
import FluentAPIViewNameAndSchema from '!!raw-loader!../../../../../static/samples/Modeling/EntityTypes/FluentAPI/ViewNameAndSchema.cs';

import DataAnnotationsFunctionNameAndSchema from '!!raw-loader!../../../../../static/samples/Modeling/EntityTypes/DataAnnotations/FunctionNameAndSchema.cs';




# 实体类型

在上下文中包含一种类型的 DbEntity 意味着它包含在 Linq EF 的模型中；我们通常将此类类型称为实体。 Linq EF 可以从/向数据库中读取和写入实体实例，如果使用的是关系数据库，Linq EF 可以通过迁移为实体创建表。

## 在模型中包含类型

按照约定，上下文的 DbEntity 属性中公开的类型作为实体包含在模型中，以及通过递归探索其他发现的实体类型的导航属性找到的任何类型

下面的代码示例中包含了所有类型：

- 包含 `Blog`，因为它在上下文的 DbEntity 属性中公开。
- 包含 `Post`，因为它是通过 Blog.Posts 导航属性发现的。

<!-- [!code-csharp[Main](../../../samples/core/Modeling/EntityTypes/EntityTypes.cs?name=EntityTypes&highlight=3,7,16)] -->

<CodeSnippets title="C#" language="csharp" fragment="EntityTypes" metastring='{3,7,16}' showLineNumbers>{EntityTypes}</CodeSnippets>

## 表名称

按照约定，每个实体类型都将设置为映射到与公开实体的 DbSet 属性名称相同的数据库表。 如果给定实体不存在 DbSet，则使用类名称。

可以手动配置表名：

<Tabs groupId="operating-code">
  <TabItem value="Annotations" label="数据注解">
    <CodeSnippets title="C#" language="csharp" fragment="TableName" metastring='{1,2}' showLineNumbers>{DataAnnotationsTableName}</CodeSnippets>
  </TabItem>
  <TabItem
    value="Fluent"
    label="Fluent API"
  >
    <CodeBlock title="C#" language="csharp" metastring='{10-14}' showLineNumbers>{FluentAPITableName}</CodeBlock>
  </TabItem>
</Tabs>

---

## 表架构

使用关系数据库时，表按约定在数据库的默认架构中创建。 例如，Microsoft SQL Server 将使用 dbo 架构（SQLite 不支持架构）。

你可以配置要在特定架构中创建的表，如下所示：

<Tabs groupId="operating-code">
  <TabItem value="Annotations" label="数据注解">
    <CodeSnippets title="C#" language="csharp" fragment="TableNameAndSchema" metastring='{1}' showLineNumbers>{DataAnnotationsTableNameAndSchema}</CodeSnippets>
  </TabItem>
  <TabItem
    value="Fluent"
    label="Fluent API"
  >
    <CodeBlock title="C#" language="csharp" fragment="TableNameAndSchema" metastring='{3-4}' showLineNumbers>{FluentAPITableNameAndSchema}</CodeBlock>
  </TabItem>
</Tabs>

---

还可以在模型级别使用 Fluent API 定义默认架构，而不是为每个表指定架构：


<Tabs groupId="operating-code">
  <TabItem value="Annotations" label="数据注解">
    <CodeBlock title="C#" language="csharp" metastring='{7,10}' showLineNumbers>{DataAnnotationsDefaultSchema}</CodeBlock>
  </TabItem>
  <TabItem
    value="Fluent"
    label="Fluent API"
  >
    <CodeSnippets title="C#" language="csharp" fragment="DefaultSchema" metastring='{3}' showLineNumbers>{FluentAPIDefaultSchema}</CodeSnippets>
  </TabItem>
</Tabs>

请注意，设置默认架构也会影响其他数据库对象，例如序列。

## 视图映射

实体类型 你可以通过使用数据注解或者 Fluent API 来映射视图.

> [!NOTE]
  EF 假定数据库中已存在引用的视图，它不会在迁移中自动创建它。
>  


<Tabs groupId="operating-code">
  <TabItem value="Annotations" label="数据注解">
    <CodeBlock title="C#" language="csharp" metastring='{7,10}' showLineNumbers>{DataAnnotationsViewNameAndSchema}</CodeBlock>
  </TabItem>
  <TabItem
    value="Fluent"
    label="Fluent API"
  >
    <CodeSnippets title="C#" language="csharp" fragment="ViewNameAndSchema" metastring='{3}' showLineNumbers>{FluentAPIViewNameAndSchema}</CodeSnippets>
  </TabItem>
</Tabs>

映射到视图将删除默认表映射，但从 EF 5.0 开始，实体类型也可以显式映射到表。 在这种情况下，查询映射将用于查询，表映射将用于更新。

> [!TIP]
//TODO:修正描述，查看当前操作意义
若要使用内存中提供程序测试映射到视图的无键实体类型，请通过 ToInMemoryQuery该提供程序将它们映射到查询。 有关详细信息，请参阅 内存中提供程序文档 。
> 

## 表值函数映射

可以将实体类型映射到表值函数 (TVF) 而不是数据库中的表。 为了说明这一点，我们定义另一个实体来表示具有多个帖子的博客。 在示例中，实体是无键的，但它不必是无键实体。

<CodeSnippets title="C#" language="csharp" fragment="BlogWithMultiplePostsEntity" showLineNumbers>{EntityTypes}</CodeSnippets>

接下来，在数据库中创建以下表值函数，该函数仅返回包含多个帖子的博客以及与其中每个博客关联的帖子数：

```sql
CREATE FUNCTION dbo.BlogsWithMultiplePosts()
RETURNS TABLE
AS
RETURN
(
    SELECT b.Url, COUNT(p.BlogId) AS PostCount
    FROM Blogs AS b
    JOIN Posts AS p ON b.BlogId = p.BlogId
    GROUP BY b.BlogId, b.Url
    HAVING COUNT(p.BlogId) > 1
)
```

现在，可以通过以下方式将实体 `BlogWithMultiplePosts` 映射到此函数：

<Tabs groupId="operating-code">
  <TabItem value="Annotations" label="数据注解">
    <CodeBlock title="C#" language="csharp" metastring='{7,10}' showLineNumbers>{DataAnnotationsFunctionNameAndSchema}</CodeBlock>
  </TabItem>
  <TabItem
    value="Fluent"
    label="Fluent API"
  >
    <CodeSnippets title="C#" language="csharp" fragment="QueryableFunctionConfigurationToFunction" showLineNumbers>{EntityTypes}</CodeSnippets>
  </TabItem>
</Tabs>

> [!NOTE]
In order to map an entity to a table-valued function the function must be parameterless.
> 
通常情况下，实体属性将映射到 TVF 返回的匹配列。 如果 TVF 返回的列名称与实体属性的名称不同，则可以使用 HasColumnName 方法配置实体的列，就像映射到常规表一样。

当实体类型映射到表值函数时，查询：

<CodeSnippets title="C#" language="csharp" fragment="ToFunctionQuery" showLineNumbers>{EntityTypesProgram}</CodeSnippets>

生成以下 SQL：

```sql
SELECT [b].[Url], [b].[PostCount]
FROM [dbo].[BlogsWithMultiplePosts]() AS [b]
WHERE [b].[PostCount] > 3
```

## 表注释

可以对数据库表设置任意文本注释，从而在数据库中记录架构：


<Tabs groupId="operating-code">
  <TabItem value="Annotations" label="数据注解">
    <CodeSnippets title="C#" language="csharp" fragment="TableComment" metastring='{1}' showLineNumbers>{DataAnnotationsTableComment}</CodeSnippets>
  </TabItem>
  <TabItem
    value="Fluent"
    label="Fluent API"
  >
    <CodeSnippets title="C#" language="csharp" fragment="TableComment" metastring='{4}' showLineNumbers>{FluentAPITableComment}</CodeSnippets>
  </TabItem>
</Tabs>

---

## Shared-type 实体类型

> [!NOTE]
Support for Shared-type 实体类型 was introduced in EF Core 5.0.
> 

实体类型 that use the same CLR type are known as shared-type 实体类型. These 实体类型 need to be configured with a unique name, which must be supplied whenever the shared-type entity type is used, in addition to the CLR type. This means that the corresponding `DbSet` property must be implemented using a `Set` call.

[!code-csharp[Main](../../../samples/core/Modeling/ShadowAndIndexerProperties/SharedType.cs?name=SharedType&highlight=3,7)]
