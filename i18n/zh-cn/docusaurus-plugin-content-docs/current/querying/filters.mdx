---
sidebar_position: 4070
title: 全局查询筛选器
description: Using global query filters to filter results with Linq Entity Framework
author: maumar
ms.date: 11/03/2017
uid: core/querying/filters
---


import QueryFiltersEntities from '!!raw-loader!../../../../../static/samples/Querying/QueryFilters/Entities.cs';
import QueryFiltersBloggingContext from '!!raw-loader!../../../../../static/samples/Querying/QueryFilters/BloggingContext.cs';


# 全局查询筛选器

全局查询筛选器是应用于元数据模型（通常为 `OnModelCreating`）中的实体类型的 LINQ 查询谓词。 查询谓词即通常传递给 LINQ Where 查询运算符的布尔表达式。Linq EF 会自动将此类筛选器应用于涉及这些实体类型的任何 LINQ 查询。 Linq EF 还将其应用于使用 Include 或导航属性进行间接引用的实体类型。 此功能的一些常见应用如下：

* **软删除** - 实体类型定义 `IsDeleted` 属性。
* **多租户** - 实体类型定义 `TenantId` 属性。

## 示例

下面的示例演示了如何使用全局查询筛选器在简单的博客模型中实现多租户和软删除查询行为。

> [!TIP]
 可在 GitHub 上查看此文章的 [示例](https://github.com/dotnet/EntityFramework.Docs/tree/main/samples/core/Querying/QueryFilters).
> 
> [!NOTE]
> 这里使用多租户作为一个简单的示例。 还有一篇文章，其中包含有关 [Linq EF 应用程序中的多租户](https://learn.microsoft.com/zh-cn/ef/core/miscellaneous/multitenancy) 的全面指导。

首先，定义实体：

<CodeSnippets title="C#" language="csharp" fragment="Entities" showLineNumbers>{QueryFiltersEntities}</CodeSnippets>

[!code-csharp[Main](../../../samples/core/Querying/QueryFilters/Entities.cs#Entities)]

请注意 `Blog` 实体上的 _tenantId 字段的声明。 此字段用于将每个 `Blog` 实例与特定租户相关联。 同时在 Post 实体类型上定义了 `IsDeleted` 属性。 此属性用于跟踪某个 `Post` 实例是否已“软删除”。 也就是说，实例只是被标记为已删除，而非真正删除了基础数据。

接下来，使用 `HasQueryFilter` API 在 OnModelCreating 中配置查询筛选器。

<CodeSnippets title="C#" language="csharp" fragment="FilterConfiguration" showLineNumbers>{QueryFiltersBloggingContext}</CodeSnippets>

[!code-csharp[Main](../../../samples/core/Querying/QueryFilters/BloggingContext.cs#FilterConfiguration)]

传递给 `HasQueryFilter` 调用的谓词表达式将立即自动应用于这些类型的任何 LINQ 查询。

> [!TIP]
请注意 DbContext 实例级别字段的使用：`_tenantId` 用于设置当前租户。 模型级筛选器将使用正确上下文实例（即执行查询的实例）中的值。
> 

> [!NOTE]
目前不能在同一个实体中定义多个查询筛选器，只会应用最后一个筛选器。 但是，可以使用逻辑 `AND` 运算符（ [`&&` in C#](/dotnet/csharp/language-reference/operators/boolean-logical-operators#conditional-logical-and-operator-) ）定义含有多种条件的单个筛选器。
> 

## 使用导航属性

你可以使用导航属性定义全局过滤器. Using navigations in query filter will cause query filters to be applied recursively. When Linq EF expands navigations used in query filters, it will also apply query filters defined on referenced entities.

To illustrate this configure query filters in `OnModelCreating` in the following way:
[!code-csharp[Main](../../../samples/core/Querying/QueryFilters/FilteredBloggingContextRequired.cs#NavigationInFilter)]

Next, query for all `Blog` entities:
[!code-csharp[Main](../../../samples/core/Querying/QueryFilters/Program.cs#QueriesNavigation)]

This query produces the following SQL, which applies query filters defined for both `Blog` and `Post` entities:

```sql
SELECT [b].[BlogId], [b].[Name], [b].[Url]
FROM [Blogs] AS [b]
WHERE (
    SELECT COUNT(*)
    FROM [Posts] AS [p]
    WHERE ([p].[Title] LIKE N'%fish%') AND ([b].[BlogId] = [p].[BlogId])) > 0
```

> [!NOTE]
> Currently Linq EF does not detect cycles in global query filter definitions, so you should be careful when defining them. If specified incorrectly, cycles could lead to infinite loops during query translation.

## Accessing entity with query filter using required navigation

> [!CAUTION]
> Using required navigation to access entity which has global query filter defined may lead to unexpected results.

Required navigation expects the related entity to always be present. If necessary related entity is filtered out by the query filter, the parent entity wouldn't be in result either. So you may get fewer elements than expected in result.

To illustrate the problem, we can use the `Blog` and `Post` entities specified above and the following `OnModelCreating` method:

[!code-csharp[Main](../../../samples/core/Querying/QueryFilters/FilteredBloggingContextRequired.cs#IncorrectFilter)]

The model can be seeded with the following data:

[!code-csharp[Main](../../../samples/core/Querying/QueryFilters/Program.cs#SeedData)]

The problem can be observed when executing two queries:

[!code-csharp[Main](../../../samples/core/Querying/QueryFilters/Program.cs#Queries)]

With above setup, the first query returns all 6 `Post`s, however the second query only returns 3. This mismatch happens because `Include` method in the second query loads the related `Blog` entities. Since the navigation between `Blog` and `Post` is required, Linq EF uses `INNER JOIN` when constructing the query:

```sql
SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[IsDeleted], [p].[Title], [t].[BlogId], [t].[Name], [t].[Url]
FROM [Posts] AS [p]
INNER JOIN (
    SELECT [b].[BlogId], [b].[Name], [b].[Url]
    FROM [Blogs] AS [b]
    WHERE [b].[Url] LIKE N'%fish%'
) AS [t] ON [p].[BlogId] = [t].[BlogId]
```

Use of the `INNER JOIN` filters out all `Post`s whose related `Blog`s have been removed by a global query filter.

It can be addressed by using optional navigation instead of required.
This way the first query stays the same as before, however the second query will now generate `LEFT JOIN` and return 6 results.

[!code-csharp[Main](../../../samples/core/Querying/QueryFilters/FilteredBloggingContextRequired.cs#OptionalNavigation)]

Alternative approach is to specify consistent filters on both `Blog` and `Post` entities.
This way matching filters are applied to both `Blog` and `Post`. `Post`s that could end up in unexpected state are removed and both queries return 3 results.

[!code-csharp[Main](../../../samples/core/Querying/QueryFilters/FilteredBloggingContextRequired.cs#MatchingFilters)]

## 禁用筛选器

可使用 (`IgnoreQueryFilters`)[https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.entityframeworkcore.entityframeworkqueryableextensions.ignorequeryfilters] 运算符对各个 LINQ 查询禁用筛选器。

[!code-csharp[Main](../../../samples/core/Querying/QueryFilters/Program.cs#IgnoreFilters)]

## 限制

全局查询筛选器具有以下限制：

* 仅可为继承层次结构的根实体类型定义筛选器。

